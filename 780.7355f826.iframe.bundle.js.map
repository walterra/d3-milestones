{"version":3,"file":"780.7355f826.iframe.bundle.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACRA;AACA;AACA;;ACFA;AAEA;AAEA;AAkBA;AAFA;AAGA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AAKA;AACA;AAEA;AAOA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;;AC5BA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAYA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAEA;AAEA;AAIA;AAGA;AAGA;AAGA;AAIA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAQA;AAWA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAkBA;AACA;AACA;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAIA;AAIA;AACA;AAEA;AAIA;AACA;AACA;AAGA;AAIA;AACA;AAIA;AAEA;AAEA;AACA;AAIA;AAEA;AAEA;AAIA;AAIA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAGA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAOA;AACA;AACA;AAEA;AAIA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAGA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;ACjXA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AC3BA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;;;;;;;;ACzEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AAIA;AAEA;AACA;AAIA;AAEA;AAKA;;AAEA;AACA;AACA;AAGA;AACA;AAGA;AAAA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAIA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AAGA;AAAA;;AAEA;AACA;AAEA;AAIA;AAAA;AAGA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AAEA;AAAA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAIA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAMA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAMA;AACA;AAOA;AACA;AAKA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAYA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AAAA;AAEA;AAKA;AAAA;AAGA;AACA;AAIA;AACA;AAIA;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChmBA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAUA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAoBA;AAfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAOA","sources":["webpack://d3-milestones/./src/stories/example-styles.less","webpack://d3-milestones/./src/styles/styles.less","webpack://d3-milestones/./src/styles/styles.less?39ee","webpack://d3-milestones/./src/stories/example-styles.less?8db7","webpack://d3-milestones/./src/_aggregate_formats.js","webpack://d3-milestones/./src/_api.js","webpack://d3-milestones/./src/_css.js","webpack://d3-milestones/./src/_defaults.js","webpack://d3-milestones/./src/_is_above.js","webpack://d3-milestones/./src/_get_attribute.js","webpack://d3-milestones/./src/_get_available_width.js","webpack://d3-milestones/./src/_get_next_group_height.js","webpack://d3-milestones/./src/_optimize.js","webpack://d3-milestones/./src/_time_format.js","webpack://d3-milestones/./src/_time_parse.js","webpack://d3-milestones/./src/_transform.js","webpack://d3-milestones/./src/main.js","webpack://d3-milestones/./src/stories/milestones.js"],"sourcesContent":["// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.d3Milestones {\n  font-family: sans-serif;\n}\n.timeline {\n  height: 900px;\n  width: 100%;\n  padding: 0 0 20px 0;\n}\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./src/stories/example-styles.less\"],\"names\":[],\"mappings\":\"AAAA;EACE,uBAAA;AACF;AAEA;EACE,aAAA;EACA,WAAA;EACA,mBAAA;AAAF\",\"sourcesContent\":[\".d3Milestones {\\n  font-family: sans-serif;\\n}\\n\\n.timeline {\\n  height: 900px;\\n  width: 100%;\\n  padding: 0 0 20px 0;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.milestones__category_label {\n  display: inline-block;\n  text-align: right;\n  font-size: 14px;\n  margin-top: -4px;\n}\n.milestones__horizontal_line {\n  position: absolute;\n  background-color: #000;\n  height: 3px;\n  margin-top: 4px;\n  margin-left: 5.5px;\n  border-radius: 1.5px;\n}\n.milestones__vertical_line {\n  position: absolute;\n  background-color: #000;\n  width: 3px;\n  margin-left: 4px;\n  margin-bottom: 5.5px;\n  border-radius: 1.5px;\n}\n.milestones__group {\n  position: absolute;\n  font-family: sans-serif;\n  font-size: 10px;\n}\n.milestones__group__bullet {\n  background-color: #fff;\n  border: 3px solid #333;\n  border-radius: 50%;\n  width: 0px;\n  height: 0px;\n  padding: 2.5px;\n}\n.milestones__group__label-horizontal,\n.milestones__group__label-vertical {\n  position: absolute;\n  padding: 0;\n  color: #666;\n}\n.milestones__group__label-horizontal {\n  border-left: 1px solid #000;\n  margin-left: 5px;\n}\n.milestones__group__label-horizontal div {\n  position: relative;\n  margin-left: 3px;\n  display: inline-block;\n}\n.milestones__group__label-vertical {\n  padding-left: 10px;\n  padding-bottom: 0px;\n  border-bottom: 1px solid #000;\n  margin-bottom: -5.5px;\n  margin-left: 10px;\n  bottom: 100%;\n  overflow: visible;\n}\n.milestones__group__label-vertical .wrapper {\n  min-width: 100px;\n  max-width: 300px;\n  border-left: 1px solid black;\n  border-bottom: 1px solid white;\n  margin-bottom: -1px;\n  padding-left: 5px;\n}\n.milestones__group__label-above-horizontal {\n  bottom: 100%;\n}\n.milestones__group__label-above-vertical {\n  padding-left: 0px;\n  padding-right: 10px;\n  right: 100%;\n  text-align: right;\n}\n.milestones__group__label-above-vertical .wrapper {\n  border-left: 0;\n  border-right: 1px solid black;\n  padding-left: 0px;\n  padding-right: 5px;\n}\n.milestones__group__label-last {\n  right: 100%;\n  border-left: 0;\n  border-right: 1px solid #000;\n  margin-left: 0;\n  margin-right: -6px;\n  text-align: right;\n}\n.milestones__group__label-last div {\n  margin-left: 0px;\n  margin-right: 3px;\n}\n.milestones__group__label__text-vertical {\n  display: table-cell;\n  vertical-align: bottom;\n}\n.milestones__group__label__text__title {\n  color: #000;\n  font-weight: bold;\n  font-size: 11px;\n  white-space: nowrap;\n}\n.milestones__group__label__text__event {\n  cursor: pointer;\n}\n.milestones__group__label__text__event--hover {\n  background: #efefef;\n  color: #313131;\n}\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./src/styles/styles.less\"],\"names\":[],\"mappings\":\"AAGE;EACE,qBAAA;EACA,iBAAA;EACA,eAAA;EACA,gBAAA;AAFJ;AAKE;EACE,kBAAA;EACA,sBAAA;EACA,WAAA;EACA,eAAA;EACA,kBAAA;EACA,oBAAA;AAHJ;AAME;EACE,kBAAA;EACA,sBAAA;EACA,UAAA;EACA,gBAAA;EACA,oBAAA;EACA,oBAAA;AAJJ;AAOE;EACE,kBAAA;EACA,uBAAA;EACA,eAAA;AALJ;AAQI;EACE,sBAAA;EACA,sBAAA;EACA,kBAAA;EACA,UAAA;EACA,WAAA;EACA,cAAA;AANN;AASI;;EACE,kBAAA;EACA,UAAA;EACA,WAAA;AANN;AAUI;EACE,2BAAA;EACA,gBAAA;AARN;AAMI;EAKI,kBAAA;EACA,gBAAA;EACA,qBAAA;AARR;AAYI;EACE,kBAAA;EACA,mBAAA;EACA,6BAAA;EACA,qBAAA;EACA,iBAAA;EACA,YAAA;EACA,iBAAA;AAVN;AAGI;EASI,gBAAA;EACA,gBAAA;EACA,4BAAA;EACA,8BAAA;EACA,mBAAA;EACA,iBAAA;AATR;AAaM;EACE,YAAA;AAXR;AAcM;EACE,iBAAA;EACA,mBAAA;EACA,WAAA;EACA,iBAAA;AAZR;AAQM;EAMI,cAAA;EACA,6BAAA;EACA,iBAAA;EACA,kBAAA;AAXV;AAeM;EACE,WAAA;EACA,cAAA;EACA,4BAAA;EACA,cAAA;EACA,kBAAA;EACA,iBAAA;AAbR;AAOM;EASI,gBAAA;EACA,iBAAA;AAbV;AAiBM;EACE,mBAAA;EACA,sBAAA;AAfR;AAkBM;EACE,WAAA;EACA,iBAAA;EACA,eAAA;EACA,mBAAA;AAhBR;AAkBM;EACE,eAAA;AAhBR;AAkBM;EACE,mBAAA;EACA,cAAA;AAhBR\",\"sourcesContent\":[\".milestones {\\n}\\n\\n  .milestones__category_label {\\n    display: inline-block;\\n    text-align: right;\\n    font-size: 14px;\\n    margin-top: -4px;\\n  }\\n\\n  .milestones__horizontal_line {\\n    position: absolute;\\n    background-color: #000;\\n    height: 3px;\\n    margin-top: 4px;\\n    margin-left: 5.5px;\\n    border-radius: 1.5px;\\n  }\\n\\n  .milestones__vertical_line {\\n    position: absolute;\\n    background-color: #000;\\n    width: 3px;\\n    margin-left: 4px;\\n    margin-bottom: 5.5px;\\n    border-radius: 1.5px;\\n  }\\n\\n  .milestones__group {\\n    position: absolute;\\n    font-family: sans-serif;\\n    font-size: 10px;\\n  }\\n\\n    .milestones__group__bullet {\\n      background-color: #fff;\\n      border: 3px solid #333;\\n      border-radius: 50%;\\n      width: 0px;\\n      height: 0px;\\n      padding: 2.5px;\\n    }\\n\\n    .milestones__group__label-horizontal,.milestones__group__label-vertical {\\n      position: absolute;\\n      padding: 0;\\n      color: #666;\\n\\n    }\\n\\n    .milestones__group__label-horizontal {\\n      border-left: 1px solid #000;\\n      margin-left: 5px;\\n\\n      div {\\n        position: relative;\\n        margin-left: 3px;\\n        display: inline-block;\\n      }\\n    }\\n\\n    .milestones__group__label-vertical {\\n      padding-left: 10px;\\n      padding-bottom: 0px;\\n      border-bottom: 1px solid #000;\\n      margin-bottom: -5.5px;\\n      margin-left: 10px;\\n      bottom: 100%;\\n      overflow: visible;\\n      .wrapper {\\n        min-width: 100px;\\n        max-width: 300px;\\n        border-left: 1px solid black;\\n        border-bottom: 1px solid white;\\n        margin-bottom: -1px;\\n        padding-left: 5px;\\n      }\\n  }\\n\\n      .milestones__group__label-above-horizontal {\\n        bottom: 100%;\\n      }\\n\\n      .milestones__group__label-above-vertical {\\n        padding-left: 0px;\\n        padding-right: 10px;\\n        right: 100%;\\n        text-align: right;\\n        .wrapper {\\n          border-left: 0;\\n          border-right: 1px solid black;\\n          padding-left: 0px;\\n          padding-right: 5px;\\n        }\\n      }\\n\\n      .milestones__group__label-last {\\n        right: 100%;\\n        border-left: 0;\\n        border-right: 1px solid #000;\\n        margin-left: 0;\\n        margin-right: -6px;\\n        text-align: right;\\n\\n        div {\\n          margin-left: 0px;\\n          margin-right: 3px;\\n        }\\n      }\\n\\n      .milestones__group__label__text-vertical {\\n        display: table-cell;\\n        vertical-align: bottom;\\n      }\\n\\n      .milestones__group__label__text__title {\\n        color: #000;\\n        font-weight: bold;\\n        font-size: 11px;\\n        white-space: nowrap;\\n      }\\n      .milestones__group__label__text__event {\\n        cursor: pointer;\\n      }\\n      .milestones__group__label__text__event--hover {\\n        background: #efefef;\\n        color: #313131;\\n      }\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\n      import API from \"!../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[12].use[1]!../../node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[12].use[2]!./styles.less\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\n\n      options.insert = insertFn.bind(null, \"head\");\n    \noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[12].use[1]!../../node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[12].use[2]!./styles.less\";\n       export default content && content.locals ? content.locals : undefined;\n","\n      import API from \"!../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[12].use[1]!../../node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[12].use[2]!./example-styles.less\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\n\n      options.insert = insertFn.bind(null, \"head\");\n    \noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[12].use[1]!../../node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[12].use[2]!./example-styles.less\";\n       export default content && content.locals ? content.locals : undefined;\n","// second, minute, hour, day, week, month, quarter, year\nexport const aggregateFormats = {\n  second: '%Y-%m-%d %H:%M:%S',\n  minute: '%Y-%m-%d %H:%M',\n  hour: '%Y-%m-%d %H:00',\n  day: '%Y-%m-%d',\n  week: '%Y week %W',\n  month: '%Y-%m',\n  quarter: '%Y-Q%Q',\n  year: '%Y',\n};\n","export default function (methods) {\n  function methodChainer(wrapper, method) {\n    return (d) => {\n      method(d);\n      return wrapper;\n    };\n  }\n\n  return Object.keys(methods).reduce((API, methodName) => {\n    API[methodName] = methodChainer(API, methods[methodName]);\n    return API;\n  }, {});\n}\n","export const cssPrefix = 'milestones';\nexport const cssCategoryClass = cssPrefix + '__category_label';\nexport const cssHorizontalLineClass = cssPrefix + '__horizontal_line';\nexport const cssVerticalLineClass = cssPrefix + '__vertical_line';\nexport const cssGroupClass = cssPrefix + '__group';\nexport const cssBulletClass = cssGroupClass + '__bullet';\nexport const cssLabelClass = cssGroupClass + '__label';\nexport const cssLastClass = cssLabelClass + '-last';\nexport const cssAboveClass = cssLabelClass + '-above';\nexport const cssTextClass = cssLabelClass + '__text';\nexport const cssTitleClass = cssTextClass + '__title';\nexport const cssEventClass = cssTextClass + '__event';\nexport const cssEventHoverClass = cssEventClass + '--hover';\n","export const DEFAULTS = {\n  DISTRIBUTION: 'top-bottom',\n  OPTIMIZE: false,\n  ORIENTATION: 'horizontal',\n  SCALE_TYPE: 'time',\n  MAPPING: {\n    category: undefined,\n    entries: undefined,\n    timestamp: 'timestamp', // Used only for time based scales\n    value: 'value', // Used only for ordinal scale values\n    text: 'text',\n    url: 'url',\n    id: 'id',\n    textStyle: 'textStyle',\n    titleStyle: 'titleStyle',\n  },\n  LABEL_FORMAT: '%Y-%m-%d %H:%M',\n  USE_LABELS: true,\n  AGGREGATE_BY: 'minute',\n  AUTO_RESIZE: true,\n  URL_TARGET: '_self',\n};\n","export function isAbove(i, distribution) {\n  let above = i % 2;\n  if (distribution === 'top') {\n    above = true;\n  } else if (distribution === 'bottom') {\n    above = false;\n  }\n  return above > 0;\n}\n","export function getAttribute(d, attribute) {\n  return parseInt(d.style[attribute].replace('px', ''), 10);\n}\n","import { getAttribute } from './_get_attribute';\n\nconst labelRightMargin = 6;\n\nexport const getAvailableWidth = (\n  aggregateFormatParse,\n  currentNode,\n  index,\n  mapping,\n  nestedData,\n  nestedNode,\n  nextCheck,\n  nextGroupHeight,\n  offset,\n  offsetCheckAttribute,\n  offsetAttribute,\n  orientation,\n  textMerge,\n  width,\n  x,\n  useNext = true,\n  scaleType = 'time' // Default to time scale if not provided\n) => {\n  // get the available width until the uber-next group\n  let nextTestIndex =\n    orientation === 'horizontal' && useNext\n      ? index + nextCheck\n      : index - nextCheck;\n\n  let nextTestItem;\n\n  do {\n    if (orientation === 'horizontal' && useNext) {\n      nextTestIndex += nextCheck;\n    } else {\n      nextTestIndex -= nextCheck;\n    }\n    nextTestItem = textMerge._groups[nextTestIndex];\n    if (typeof nextTestItem === 'undefined') {\n      break;\n    }\n  } while (nextGroupHeight >= nextTestItem[0][offsetAttribute]);\n\n  let uberNextItem;\n\n  if (typeof mapping.category === 'undefined') {\n    uberNextItem = nestedData[nestedNode.timelineIndex][nextTestIndex];\n  } else {\n    uberNextItem = nestedData[nestedNode.timelineIndex].entries[nextTestIndex];\n  }\n\n  let availableWidth = getAttribute(currentNode, offsetCheckAttribute);\n\n  if (typeof uberNextItem !== 'undefined') {\n    const value =\n      scaleType === 'ordinal'\n        ? uberNextItem.key\n        : aggregateFormatParse(uberNextItem.key);\n    const offsetUberNextItem = x(value);\n\n    if ((orientation === 'horizontal') & useNext) {\n      availableWidth = offsetUberNextItem - offset - labelRightMargin;\n    } else if ((orientation === 'horizontal') & !useNext) {\n      availableWidth = offsetUberNextItem - labelRightMargin;\n    } else {\n      availableWidth = offset - offsetUberNextItem - labelRightMargin;\n    }\n  } else {\n    if ((orientation === 'horizontal') & useNext) {\n      availableWidth = width - offset - labelRightMargin;\n    } else if ((orientation === 'horizontal') & !useNext) {\n      availableWidth = offset - labelRightMargin;\n    } else {\n      availableWidth = offset - labelRightMargin;\n    }\n  }\n\n  if (nextCheck < 0) {\n    return Math.min(offset, availableWidth);\n  } else {\n    return availableWidth;\n  }\n};\n","const getNextGroup = (orientation, nodes, index, nextCheck) => {\n  const nextGroup =\n    orientation === 'horizontal'\n      ? nodes[index + nextCheck]\n      : nodes[index - nextCheck];\n\n  return nextGroup;\n};\n\nexport const getNextGroupHeight = (\n  index,\n  nextCheck,\n  nodes,\n  offsetAttribute,\n  orientation\n) => {\n  // get the height of the next group\n  const defaultPadding = 3;\n\n  const nextGroup = getNextGroup(orientation, nodes, index, nextCheck);\n\n  let nextGroupHeight = 0;\n\n  if (typeof nextGroup !== 'undefined') {\n    nextGroupHeight = nextGroup[0][offsetAttribute] + defaultPadding;\n  }\n\n  return nextGroupHeight;\n};\n","import * as dom from 'd3-selection';\nimport { nest } from 'd3-collection';\n\nimport { cssLastClass } from './_css';\nimport { getAttribute } from './_get_attribute';\nimport { getAvailableWidth } from './_get_available_width';\nimport { getNextGroupHeight } from './_get_next_group_height';\nimport { isAbove } from './_is_above';\n\nconst MAX_OPTIMIZER_RUNS = 20;\n\nconst getIntValueFromPxAttribute = (domElement, attribute) => {\n  return parseInt(domElement.style(attribute).replace('px', ''), 10);\n};\n\nconst getParentElement = (domElement) =>\n  domElement.select(function () {\n    return this.parentNode;\n  });\n\nconst isSameDistribution = (index, nextCheck, overlapCheckIndex) => {\n  const itemRowCheck = index % nextCheck;\n  const distributionCheck = (overlapCheckIndex + itemRowCheck) % nextCheck;\n\n  return distributionCheck !== 0;\n};\n\nexport const optimize = (\n  aggregateFormatParse,\n  distribution,\n  labelMaxWidth,\n  mapping,\n  nestedData,\n  orientation,\n  textMerge,\n  width,\n  widthAttribute,\n  x,\n  scaleType = 'time' // Default to time scale if not provided\n) => {\n  const nestedNodes = nest()\n    .key((d) => {\n      return dom.selectAll(d).data()[0].timelineIndex;\n    })\n    .entries(textMerge._groups);\n\n  const nextCheck = distribution === 'top-bottom' ? 2 : 1;\n\n  const runOptimizer = (optimizerRuns) => {\n    let updated = 0;\n\n    nestedNodes.forEach((d) => {\n      const nodes = d.values;\n      nodes.forEach((node) => {\n        const d = dom.selectAll(node).data()[0];\n\n        const offsetComparator = orientation === 'horizontal' ? 60 : 20;\n\n        const index =\n          orientation === 'horizontal' ? nodes.length - d.index - 1 : d.index;\n\n        const item = dom.selectAll(nodes[index]).data()[0];\n        const value =\n          scaleType === 'ordinal' ? item.key : aggregateFormatParse(item.key);\n        const offset = x(value);\n        const currentNode = nodes[index][0];\n\n        let isLast = index === nodes.length - 1;\n        if (!isLast && distribution === 'top-bottom') {\n          isLast = index === nodes.length - 2 && width - offset < 60;\n        }\n\n        const scrollCheckAttribute =\n          orientation === 'horizontal' ? 'offsetWidth' : 'offsetHeight';\n\n        const offsetCheckAttribute =\n          orientation === 'horizontal' ? 'width' : 'height';\n\n        const offsetCheck = getAttribute(currentNode, offsetCheckAttribute);\n\n        const domElement = dom.selectAll(nodes[index]);\n\n        let backwards = isLast\n          ? true\n          : getParentElement(domElement).classed(cssLastClass);\n\n        const offsetAttribute =\n          orientation === 'horizontal' ? 'offsetHeight' : 'offsetWidth';\n\n        const paddingAbove =\n          orientation === 'horizontal' ? 'padding-bottom' : 'padding-right';\n\n        const paddingBelow =\n          orientation === 'horizontal' ? 'padding-top' : 'padding-left';\n\n        const padding = isAbove(index, distribution)\n          ? paddingAbove\n          : paddingBelow;\n\n        const overflow = backwards\n          ? offset - offsetCheck < 0\n          : offset + offsetCheck > width;\n\n        // Because on a resize a previous optimization could already have\n        // repositioned items, we reset them on the first optimizer run\n        if (optimizerRuns === 0) {\n          backwards = isLast ? true : overflow;\n          domElement.style(padding, '0px');\n          getParentElement(domElement).classed(cssLastClass, backwards);\n        }\n\n        if (\n          currentNode[scrollCheckAttribute] > offsetCheck ||\n          offsetCheck < offsetComparator ||\n          backwards ||\n          overflow\n        ) {\n          let availableWidth = null;\n          let runs = 0;\n          let nextCheckIterator =\n            orientation === 'horizontal' ? nextCheck - 1 : nextCheck + 1;\n\n          do {\n            if (orientation === 'horizontal') {\n              nextCheckIterator++;\n            } else {\n              nextCheckIterator--;\n            }\n\n            runs++;\n\n            if (nextCheckIterator > 0) {\n              const nextGroupHeight = getNextGroupHeight(\n                index,\n                nextCheck,\n                nodes,\n                offsetAttribute,\n                orientation\n              );\n\n              const previousGroupHeight =\n                orientation === 'horizontal'\n                  ? getNextGroupHeight(\n                      index,\n                      nextCheck * -1,\n                      nodes,\n                      offsetAttribute,\n                      orientation\n                    )\n                  : nextGroupHeight;\n\n              let useNext = nextGroupHeight <= previousGroupHeight && !isLast;\n\n              if (!useNext && !isLast) {\n                useNext = offset < offsetComparator;\n              }\n\n              let groupHeight = useNext ? nextGroupHeight : previousGroupHeight;\n              if (isLast) {\n                groupHeight = 0;\n              }\n              const check = useNext ? nextCheck : nextCheck * -1;\n\n              domElement.style(padding, groupHeight + 'px');\n\n              getParentElement(domElement).classed(cssLastClass, !useNext);\n\n              availableWidth = getAvailableWidth(\n                aggregateFormatParse,\n                currentNode,\n                index,\n                mapping,\n                nestedData,\n                d,\n                check,\n                groupHeight,\n                offset,\n                offsetCheckAttribute,\n                offsetAttribute,\n                orientation,\n                textMerge,\n                width,\n                x,\n                useNext,\n                scaleType // Pass scale type to getAvailableWidth\n              );\n            }\n          } while (\n            availableWidth < currentNode[scrollCheckAttribute] &&\n            runs < MAX_OPTIMIZER_RUNS\n          );\n\n          if (orientation === 'horizontal') {\n            availableWidth = Math.min(labelMaxWidth, availableWidth);\n          }\n\n          // because labels could be left or right aligned,\n          // we shrink the available width to the inner text width\n          // so labels facing each other will require less space.\n          domElement.style(widthAttribute, availableWidth + 'px');\n          const innerWidth = getIntValueFromPxAttribute(\n            domElement.select('.wrapper'),\n            'width'\n          );\n          if (innerWidth < availableWidth) {\n            availableWidth = innerWidth + 6;\n            domElement.style(widthAttribute, availableWidth + 'px');\n          }\n\n          if (optimizerRuns > 0 && orientation === 'horizontal') {\n            const itemWidth = getIntValueFromPxAttribute(domElement, 'width');\n            const checkOffset = backwards\n              ? offset - itemWidth\n              : offset + itemWidth;\n\n            nodes.forEach((overlapCheckNode, overlapCheckIndex) => {\n              const overlapCheckItem = dom\n                .selectAll(overlapCheckNode)\n                .data()[0];\n\n              if (\n                overlapCheckItem.key === item.key ||\n                isSameDistribution(index, nextCheck, overlapCheckIndex)\n              ) {\n                return;\n              }\n\n              const overlapValue =\n                scaleType === 'ordinal'\n                  ? overlapCheckItem.key\n                  : aggregateFormatParse(overlapCheckItem.key);\n              let overlapCheckOffset = x(overlapValue) - 5;\n              const overlapItemOffsetAnchor = overlapCheckOffset;\n              const overlapCheckDomElement = dom.selectAll(\n                nodes[overlapCheckIndex]\n              );\n              const overlapCheckBackwards = getParentElement(\n                overlapCheckDomElement\n              ).classed(cssLastClass);\n\n              if (backwards && !overlapCheckBackwards) {\n                const overlapCheckItemWidth = getIntValueFromPxAttribute(\n                  overlapCheckDomElement,\n                  'width'\n                );\n                overlapCheckOffset =\n                  overlapCheckOffset + overlapCheckItemWidth + 5;\n              }\n\n              if (!backwards && overlapCheckBackwards) {\n                const overlapCheckItemWidth = getIntValueFromPxAttribute(\n                  overlapCheckDomElement,\n                  'width'\n                );\n                overlapCheckOffset =\n                  overlapCheckOffset - overlapCheckItemWidth - 5;\n              }\n\n              const overlapCheck1 = backwards\n                ? overlapCheckOffset > checkOffset\n                : checkOffset > overlapItemOffsetAnchor;\n\n              const overlapCheck2 = backwards\n                ? overlapItemOffsetAnchor < offset\n                : overlapItemOffsetAnchor > offset;\n\n              if (overlapCheck1 && overlapCheck2) {\n                const overlapCheckHeight = overlapCheckNode[0][offsetAttribute];\n                const itemPadding = getIntValueFromPxAttribute(\n                  domElement,\n                  padding\n                );\n\n                if (itemPadding < overlapCheckHeight) {\n                  // offsetComparator\n                  // find out if there's enough place to get rid of overlap\n                  // by adjusted the items width\n                  const checkWidth = backwards\n                    ? overlapCheckOffset - checkOffset\n                    : checkOffset - overlapItemOffsetAnchor;\n                  const currentWidth = getIntValueFromPxAttribute(\n                    domElement,\n                    widthAttribute\n                  );\n                  const reducedWidth = currentWidth - checkWidth - 6;\n\n                  if (reducedWidth > offsetComparator) {\n                    availableWidth = Math.min(availableWidth, reducedWidth);\n                    domElement.style(widthAttribute, `${availableWidth}px`);\n                  } else {\n                    domElement.style(padding, `${overlapCheckHeight + 5}px`);\n                  }\n                  updated++;\n                }\n              }\n            });\n\n            // The optimizer might push all labels too far up. If all labels\n            // have a minimum padding of more than 0, we'll shrink all offsets\n            // back so the label with the smallest padding ends up directly\n            // at the timeline.\n\n            let minPadding = Number.POSITIVE_INFINITY;\n            nodes.forEach((overlapCheckNode, overlapCheckIndex) => {\n              const checkSameOrientation = isAbove(\n                overlapCheckIndex,\n                distribution\n              )\n                ? paddingAbove\n                : paddingBelow;\n\n              if (checkSameOrientation !== padding) {\n                return;\n              }\n\n              const overlapCheckDomElement = dom.selectAll(\n                nodes[overlapCheckIndex]\n              );\n\n              const itemPadding = getIntValueFromPxAttribute(\n                overlapCheckDomElement,\n                padding\n              );\n              minPadding = Math.min(minPadding, itemPadding);\n            });\n\n            if (minPadding > 0) {\n              nodes.forEach((overlapCheckNode, overlapCheckIndex) => {\n                const itemRowCheck = index % nextCheck;\n                const distributionCheck =\n                  (overlapCheckIndex + itemRowCheck) % nextCheck;\n\n                if (distributionCheck !== 0) {\n                  return;\n                }\n\n                const overlapCheckDomElement = dom.selectAll(\n                  nodes[overlapCheckIndex]\n                );\n                const itemPadding = getIntValueFromPxAttribute(\n                  overlapCheckDomElement,\n                  padding\n                );\n                overlapCheckDomElement.style(\n                  padding,\n                  `${itemPadding - minPadding}px`\n                );\n              });\n            }\n          }\n        }\n      });\n    });\n\n    return updated;\n  };\n\n  let optimizerRuns = 0;\n  let updated = 0;\n\n  do {\n    updated = runOptimizer(optimizerRuns);\n    optimizerRuns++;\n\n    // make sure we run a second optimizer call\n    if (optimizerRuns === 1) {\n      updated = 1;\n    }\n  } while (optimizerRuns < MAX_OPTIMIZER_RUNS && updated > 0);\n};\n","import { timeFormat as d3TimeFormat } from 'd3-time-format';\n\nimport { aggregateFormats } from './_aggregate_formats';\n\nexport function timeFormat(f) {\n  if (f === '%Y-Q%Q') {\n    const quarterFormatter = d3TimeFormat(aggregateFormats.month);\n    return (d) => {\n      const formattedDate = quarterFormatter(d);\n      const month = formattedDate.split('-')[1];\n      const quarter = Math.ceil(parseInt(month) / 3);\n      return formattedDate.split('-')[0] + '-Q' + quarter;\n    };\n  }\n  return d3TimeFormat(f);\n}\n","import { timeParse as d3TimeParse } from 'd3-time-format';\n\nimport { aggregateFormats } from './_aggregate_formats';\n\nexport function timeParse(f) {\n  if (f === '%Y-Q%Q') {\n    const quarterParser = d3TimeParse(aggregateFormats.month);\n    return (d) => {\n      if (d.search('-Q') === -1) {\n        const quarter = Math.ceil(parseInt(d.split('-')[1]) / 3);\n        const quarterFirstMonthAsString = quarter * 3 - 2 + '';\n        const quarterFirstMonthLeadingZero =\n          quarterFirstMonthAsString.length < 2\n            ? '0' + quarterFirstMonthAsString\n            : quarterFirstMonthAsString;\n        return quarterParser(\n          d.split('-')[0] + '-' + quarterFirstMonthLeadingZero\n        );\n      } else {\n        const monthAsString = parseInt(d.split('-')[1][1]) * 3 + '';\n        const monthLeadingZero =\n          monthAsString.length < 2 ? '0' + monthAsString : monthAsString;\n        return quarterParser(d.split('-')[0] + '-' + monthLeadingZero);\n      }\n    };\n  }\n  return d3TimeParse(f);\n}\n","import { ascending } from 'd3-array';\nimport { nest } from 'd3-collection';\n\nexport function transform(\n  aggregateFormat,\n  data,\n  mapping,\n  parseTime,\n  scaleType = 'time'\n) {\n  // Choose grouping function based on scale type\n  const groupBy = function (d) {\n    if (scaleType === 'ordinal') {\n      // For ordinal scales, use the value field directly\n      return d[mapping.value];\n    } else {\n      // For time scales, use the timestamp with formatting\n      return aggregateFormat(parseTime(d[mapping.timestamp]));\n    }\n  };\n\n  // test for different data structures\n  if (\n    typeof mapping.category !== 'undefined' &&\n    typeof mapping.entries !== 'undefined'\n  ) {\n    data = data.map((timeline, timelineIndex) => {\n      return {\n        category: timeline[mapping.category],\n        entries: getNestedEntries(timeline[mapping.entries], timelineIndex),\n      };\n    });\n    return data;\n  } else if (typeof data !== 'undefined' && !Array.isArray(data[0])) {\n    data = [data];\n  }\n\n  function getNestedEntries(t, tI) {\n    // For ordinal scales, we need to preserve the original order\n    // For time scales, we want to sort by time (ascending)\n    const nested =\n      scaleType === 'ordinal'\n        ? nest().key(groupBy).entries(t) // Don't sort keys for ordinal scale\n        : nest().key(groupBy).sortKeys(ascending).entries(t);\n\n    // Save original data order for ordinal scales\n    if (scaleType === 'ordinal') {\n      // Create a map of original positions\n      const originalPositions = {};\n      t.forEach((item, index) => {\n        const key = groupBy(item);\n        if (!originalPositions[key] && originalPositions[key] !== 0) {\n          originalPositions[key] = index;\n        }\n      });\n\n      // Sort the nested entries by their original position\n      nested.sort((a, b) => {\n        return (\n          (originalPositions[a.key] || 0) - (originalPositions[b.key] || 0)\n        );\n      });\n    }\n\n    return nested.map((d, dI) => {\n      d.index = dI;\n      d.timelineIndex = tI;\n      d.scaleType = scaleType; // Pass the scale type to the data object\n      return d;\n    });\n  }\n\n  return data.map((t, tI) => getNestedEntries(t, tI));\n}\n","import * as dom from 'd3-selection';\nimport * as scale from 'd3-scale';\nimport { extent, max } from 'd3-array';\nimport { isoParse } from 'd3-time-format';\n\nimport { aggregateFormats } from './_aggregate_formats';\nimport api from './_api';\nimport {\n  cssPrefix,\n  cssCategoryClass,\n  cssHorizontalLineClass,\n  cssVerticalLineClass,\n  cssGroupClass,\n  cssBulletClass,\n  cssLabelClass,\n  cssAboveClass,\n  cssTextClass,\n  cssTitleClass,\n  cssEventClass,\n  cssEventHoverClass,\n} from './_css';\nimport { DEFAULTS } from './_defaults';\nimport { isAbove } from './_is_above';\nimport { optimize as optimizeFn } from './_optimize';\nimport { timeFormat } from './_time_format';\nimport { timeParse } from './_time_parse';\nimport { transform } from './_transform';\n\nexport default function milestones(selector) {\n  let distribution = DEFAULTS.DISTRIBUTION;\n  function setDistribution(d) {\n    distribution = d;\n  }\n\n  let optimizeLayout = DEFAULTS.OPTIMIZE;\n  function setOptimizeLayout(d) {\n    optimizeLayout = d;\n  }\n\n  let orientation = DEFAULTS.ORIENTATION;\n  function setOrientation(d) {\n    orientation = d;\n    // purge the DOM to avoid layout issues when switching orientation\n    dom.select(selector).html('');\n  }\n\n  let scaleType = DEFAULTS.SCALE_TYPE;\n  function setScaleType(d) {\n    if (d === 'time' || d === 'ordinal') {\n      scaleType = d;\n      // purge the DOM to avoid layout issues when switching scale type\n      dom.select(selector).html('');\n    }\n  }\n\n  let parseTime = isoParse;\n  function setParseTime(d) {\n    parseTime = timeParse(d);\n  }\n\n  let mapping = Object.assign({}, DEFAULTS.MAPPING);\n  function assignMapping(d) {\n    mapping = Object.assign({}, mapping, d);\n  }\n\n  let labelFormat;\n  function setLabelFormat(d) {\n    labelFormat = timeFormat(d);\n  }\n  setLabelFormat(DEFAULTS.LABEL_FORMAT);\n\n  let range;\n  function setRange(d) {\n    if (Array.isArray(d) && d.length == 2) {\n      range = d;\n    }\n  }\n\n  let useLabels;\n  function setUseLabels(d) {\n    useLabels = d;\n  }\n  setUseLabels(DEFAULTS.USE_LABELS);\n\n  let urlTarget;\n  function setUrlTarget(d) {\n    if (\n      typeof d === 'string' &&\n      ['_blank', '_self', '_parent', '_top'].includes(d.toLowerCase())\n    ) {\n      urlTarget = d;\n    }\n  }\n  setUrlTarget(DEFAULTS.URL_TARGET);\n\n  // set callback for event mouseover\n  let callBackMouseOver;\n  function setEventMouseOverCallback(callback) {\n    callBackMouseOver = callback;\n  }\n  function eventMouseOver(d) {\n    if (typeof callBackMouseOver === 'function') {\n      dom.select(this).classed(cssEventHoverClass, true);\n      callBackMouseOver(d);\n    }\n    return d;\n  }\n\n  // set callback for event mouseleave\n  let callBackMouseLeave;\n  function setEventMouseLeaveCallback(callback) {\n    callBackMouseLeave = callback;\n  }\n  function eventMouseLeave(d) {\n    if (typeof callBackMouseOver === 'function') {\n      dom.select(this).classed(cssEventHoverClass, false);\n      callBackMouseLeave(d);\n    }\n    return d;\n  }\n\n  // set callback for event click\n  let callbackClick;\n  function setEventClickCallback(callback) {\n    callbackClick = callback;\n  }\n  function eventClick(d) {\n    if (typeof callbackClick === 'function') {\n      callbackClick(d);\n    }\n    return d;\n  }\n\n  // set callback for post-render operations\n  let callbackRender;\n  function renderCallback(callback) {\n    callbackRender = callback;\n  }\n\n  let aggregateFormat = timeFormat(aggregateFormats[DEFAULTS.AGGREGATE_BY]);\n  let aggregateFormatParse = timeParse(aggregateFormats[DEFAULTS.AGGREGATE_BY]);\n\n  function setAggregateBy(d) {\n    aggregateFormat = timeFormat(aggregateFormats[d]);\n    aggregateFormatParse = timeParse(aggregateFormats[d]);\n    setLabelFormat(aggregateFormats[d]);\n  }\n\n  const autoResize = { current: DEFAULTS.AUTO_RESIZE };\n\n  const resizeHandler = () => {\n    if (dom.select(selector).node() !== null) {\n      window.requestAnimationFrame(() => {\n        if (autoResize.current) {\n          render(); // Render without data parameter to re-render existing data\n        }\n      });\n    }\n  };\n\n  const resizeObserver = new ResizeObserver(resizeHandler);\n  resizeObserver.observe(\n    typeof selector === 'string' ? document.querySelector(selector) : selector\n  );\n\n  function setAutoResize(d) {\n    autoResize.current = d;\n  }\n\n  function render(data) {\n    // Simple render method with a single data parameter\n\n    const widthAttribute = orientation === 'horizontal' ? 'width' : 'height';\n    const marginTimeAttribute =\n      orientation === 'horizontal' ? 'margin-left' : 'margin-top';\n    const cssLineClass =\n      orientation === 'horizontal'\n        ? cssHorizontalLineClass\n        : cssVerticalLineClass;\n    const labelMaxWidth = orientation === 'horizontal' ? 180 : 100;\n\n    const timelineSelection = dom.select(selector).selectAll('.' + cssPrefix);\n    const nestedData =\n      typeof data !== 'undefined'\n        ? transform(aggregateFormat, data, mapping, parseTime, scaleType)\n        : timelineSelection.data();\n    const timeline = timelineSelection.data(nestedData);\n\n    const timelineEnter = timeline\n      .enter()\n      .append('div')\n      .attr('class', cssPrefix);\n\n    timeline.exit().remove();\n\n    // rightMargin compensates for the right most bullet position\n    const rightMargin = 11;\n    const selectorWidth =\n      parseFloat(dom.select(selector).style(widthAttribute)) - rightMargin;\n\n    if (typeof mapping.category !== 'undefined') {\n      timelineEnter\n        .append('div')\n        .attr('class', cssCategoryClass)\n        .text((d) => d.category);\n\n      timelineEnter\n        .append('div')\n        .attr('class', 'data-js-timeline')\n        .append('div')\n        .attr('class', cssLineClass);\n    } else {\n      timelineEnter.append('div').attr('class', cssLineClass);\n    }\n    const timelineMerge = timeline.merge(timelineEnter);\n\n    const categoryLabelWidths = [];\n    const categoryLabels = timelineMerge.selectAll('.' + cssCategoryClass);\n    categoryLabels.each((d, i, node) => {\n      categoryLabelWidths.push(node[i].offsetWidth);\n    });\n    const maxCategoryLabelWidth = Math.round(max(categoryLabelWidths) || 0);\n    const timelineLeftMargin = 10;\n    const width = selectorWidth - maxCategoryLabelWidth - timelineLeftMargin;\n    categoryLabels.style('width', maxCategoryLabelWidth + 'px');\n    if (orientation === 'vertical') {\n      categoryLabels.style('margin-left', '-50%');\n      categoryLabels.style('text-align', 'center');\n    }\n    timelineMerge\n      .selectAll('.data-js-timeline')\n      .style(\n        marginTimeAttribute,\n        maxCategoryLabelWidth + timelineLeftMargin + 'px'\n      );\n    timelineMerge\n      .selectAll('.' + cssLineClass)\n      .style(widthAttribute, width + 'px');\n\n    const groupSelector =\n      typeof mapping.category === 'undefined'\n        ? timelineMerge\n        : timelineMerge.selectAll('.data-js-timeline');\n    const groupSelection = groupSelector.selectAll('.' + cssGroupClass);\n\n    const group = groupSelection.data((d) => {\n      return typeof mapping.category === 'undefined' ? d : d.entries;\n    });\n\n    const allKeys = nestedData.reduce((keys, timeline) => {\n      const t =\n        typeof mapping.category === 'undefined' ? timeline : timeline.entries;\n      t.map((d) => keys.push(d.key));\n      return keys;\n    }, []);\n\n    const domain =\n      typeof range !== 'undefined'\n        ? range.map(aggregateFormatParse)\n        : extent(allKeys, (d) => aggregateFormatParse(d));\n\n    // Create the appropriate scale based on scaleType\n    const x =\n      scaleType === 'ordinal'\n        ? scale.scalePoint().range([0, width]).domain(allKeys) // Keep original order for ordinal scales\n        : scale\n            .scaleTime()\n            .rangeRound([0, width])\n            // sets oldest and newest date as the scales domain\n            .domain(domain);\n\n    const groupEnter = group.enter().append('div').attr('class', cssGroupClass);\n\n    group.exit().remove();\n\n    groupEnter.append('div').attr('class', cssBulletClass);\n\n    const groupMerge = groupEnter\n      .merge(group)\n      .style(marginTimeAttribute, (d) => {\n        // For ordinal scale, use the key directly; for time scale, parse it\n        d.scaleType = scaleType; // Ensure scale type is passed to data\n        const value =\n          scaleType === 'ordinal' ? d.key : aggregateFormatParse(d.key);\n        return x(value) + 'px';\n      });\n\n    if (useLabels) {\n      const label = groupMerge\n        .selectAll('.' + cssLabelClass + '-' + orientation)\n        .data((d) => [d]);\n\n      const labelMerge = label\n        .enter()\n        .append('div')\n        .attr('class', cssLabelClass + '-' + orientation)\n        .merge(label)\n        // .classed(cssLastClass, (d) => {\n        //   const mostRightPosition = Math.round(x.range()[1]);\n        //   const currentPosition = x(aggregateFormatParse(d.key));\n        //   return (\n        //     mostRightPosition === currentPosition &&\n        //     orientation === 'horizontal'\n        //   );\n        // })\n        .classed(cssAboveClass + '-' + orientation, (d) =>\n          isAbove(d.index, distribution)\n        );\n\n      const text = labelMerge\n        .selectAll('.' + cssTextClass + '-' + orientation)\n        .data((d) => [d]);\n\n      const textEnter = text\n        .enter()\n        .append('div')\n        .attr('class', cssTextClass + '-' + orientation)\n        .merge(text)\n        .style(widthAttribute, (d) => {\n          // calculate the available width\n          d.scaleType = scaleType; // Ensure scale type is passed to data\n          const value =\n            scaleType === 'ordinal' ? d.key : aggregateFormatParse(d.key);\n          const offset = x(value);\n          // get the next and previous item on the same lane\n          let nextItem;\n          let previousItem;\n          let itemNumTotal;\n          const itemNum = d.index + 1;\n          const nextCheck = distribution === 'top-bottom' ? 2 : 1;\n          if (typeof mapping.category === 'undefined') {\n            nextItem = nestedData[d.timelineIndex][d.index + nextCheck];\n            previousItem = nestedData[d.timelineIndex][d.index - nextCheck];\n            itemNumTotal = nestedData[d.timelineIndex].length;\n          } else {\n            nextItem = nestedData[d.timelineIndex].entries[d.index + nextCheck];\n            previousItem =\n              nestedData[d.timelineIndex].entries[d.index - nextCheck];\n            itemNumTotal = nestedData[d.timelineIndex].entries.length;\n          }\n\n          let availableWidth;\n          const compareItem1 =\n            orientation === 'horizontal' ? nextItem : previousItem;\n          const compareItem2 =\n            orientation === 'horizontal' ? previousItem : nextItem;\n\n          if (typeof compareItem1 !== 'undefined') {\n            // Pass scale type to next item\n            compareItem1.scaleType = scaleType;\n            const nextValue =\n              scaleType === 'ordinal'\n                ? compareItem1.key\n                : aggregateFormatParse(compareItem1.key);\n            const offsetNextItem = x(nextValue);\n            availableWidth =\n              orientation === 'horizontal'\n                ? offsetNextItem - offset\n                : offset - offsetNextItem;\n\n            if (itemNumTotal - itemNum === 2) {\n              availableWidth /= 2;\n            }\n          } else {\n            if (itemNumTotal - itemNum === 1) {\n              availableWidth =\n                orientation === 'horizontal' ? width - offset : offset;\n            } else if (itemNumTotal - itemNum === 0) {\n              if (typeof compareItem2 !== 'undefined') {\n                // Pass scale type to previous item\n                compareItem2.scaleType = scaleType;\n                const prevValue =\n                  scaleType === 'ordinal'\n                    ? compareItem2.key\n                    : aggregateFormatParse(compareItem2.key);\n                const offsetPreviousItem = x(prevValue);\n                availableWidth =\n                  orientation === 'horizontal'\n                    ? (width - offsetPreviousItem) / 2\n                    : offsetPreviousItem / 2;\n              } else {\n                availableWidth = width;\n              }\n            }\n          }\n\n          const labelRightMargin = 6;\n          const availableWidthWithMargin = Math.max(\n            0,\n            availableWidth - labelRightMargin\n          );\n          const finalWidth = Math.min(\n            orientation === 'horizontal'\n              ? labelMaxWidth\n              : availableWidthWithMargin,\n            availableWidthWithMargin\n          );\n          return finalWidth + 'px';\n        })\n        .each(function (d) {\n          const above = isAbove(d.index, distribution);\n\n          const wrapper = dom.select(this);\n          wrapper.html(null);\n\n          const titleStyle = d.values.reduce((p, c) => {\n            if (c[mapping.titleStyle] !== undefined) {\n              return Object.assign(p, c[mapping.titleStyle]);\n            }\n            return p;\n          }, {});\n\n          const element = wrapper.append('div').classed('wrapper', true);\n\n          if (!above || orientation === 'vertical') {\n            const titleSpan = element\n              .append('span')\n              .classed(cssTitleClass, true);\n\n            // Format label based on scale type\n            if (scaleType === 'ordinal') {\n              titleSpan.text(d.key);\n            } else {\n              titleSpan.text(labelFormat(aggregateFormatParse(d.key)));\n            }\n\n            Object.entries(titleStyle).forEach(([prop, val]) =>\n              titleSpan.style(prop, val)\n            );\n\n            element.append('br');\n          }\n\n          d.values.map((v, i) => {\n            if (i > 0) {\n              element.append('br');\n            }\n\n            const textStyle = Object.assign({}, v[mapping.textStyle]);\n\n            const t = v[mapping.text];\n            let item;\n            // test if text is an image filename,\n            // if so return an image tag with the filename as the source\n            if (\n              ['jpg', 'jpeg', 'gif', 'png', 'webp'].indexOf(\n                t.split('.').pop()\n              ) > -1\n            ) {\n              item = element\n                .append('img')\n                .classed('milestones-label', true)\n                .classed('milestones-image-label', true)\n                .attr('height', '100')\n                .attr('src', t);\n            } else if (v[mapping.url]) {\n              item = element\n                .append('a')\n                .classed('milestones-label', true)\n                .classed('milestones-link-label', true)\n                .attr('href', v[mapping.url])\n                .attr('target', urlTarget)\n                .text(t);\n            } else {\n              item = element\n                .append('span')\n                .classed('milestones-label', true)\n                .classed('milestones-text-label', true)\n                .text(t);\n            }\n\n            // Apply custom ID if provided\n            if (v[mapping.id]) {\n              item.attr('id', v[mapping.id]);\n            }\n\n            item.datum({\n              text: v[mapping.text],\n              timestamp: v[mapping.timestamp],\n              attributes: v, // original value of an object passed to the milestone\n            });\n\n            if (\n              typeof callbackClick === 'function' ||\n              typeof callBackMouseLeave === 'function' ||\n              typeof callBackMouseOver === 'function'\n            ) {\n              item.classed(cssEventClass, true);\n            }\n\n            if (typeof callbackClick === 'function') {\n              item.on('click', eventClick);\n            }\n\n            if (typeof callBackMouseLeave === 'function') {\n              item.on('mouseleave', eventMouseLeave);\n            }\n\n            if (typeof callBackMouseOver === 'function') {\n              item.on('mouseover', eventMouseOver);\n            }\n\n            Object.entries(textStyle).forEach(([prop, val]) =>\n              item.style(prop, val)\n            );\n          });\n\n          if (above && orientation === 'horizontal') {\n            element.append('br');\n            const titleSpan = element\n              .append('span')\n              .classed(cssTitleClass, true);\n\n            // Format label based on scale type\n            if (scaleType === 'ordinal') {\n              titleSpan.text(d.key);\n            } else {\n              titleSpan.text(labelFormat(aggregateFormatParse(d.key)));\n            }\n\n            Object.entries(titleStyle).forEach(([prop, val]) =>\n              titleSpan.style(prop, val)\n            );\n          }\n        });\n\n      const textMerge = text.merge(textEnter);\n\n      textMerge.style('padding-top', '0px').style('padding-bottom', '0px');\n\n      if (optimizeLayout) {\n        optimizeFn(\n          aggregateFormatParse,\n          distribution,\n          labelMaxWidth,\n          mapping,\n          nestedData,\n          orientation,\n          textMerge,\n          width,\n          widthAttribute,\n          x,\n          scaleType // Pass scale type to optimizer\n        );\n      }\n    } else {\n      groupMerge.selectAll('.' + cssLabelClass + '-' + orientation).remove();\n    }\n\n    // finally, adjust offset, height and width of the whole timeline\n    timelineMerge.each((d, i, node) => {\n      const margin = 10;\n      const maxAboveHeight = max(\n        dom.select(node[i]).selectAll('* .' + cssAboveClass + '-' + orientation)\n          ._groups[0],\n        (d) => d.offsetHeight\n      );\n      const maxBelowHeight = max(\n        dom\n          .select(node[i])\n          .selectAll('* :not(.' + cssAboveClass + '-' + orientation + ')')\n          ._groups[0],\n        (d) => d.offsetHeight\n      );\n\n      if (orientation === 'horizontal') {\n        dom\n          .select(node[i])\n          .style('margin-top', margin + (maxAboveHeight || 0) + 'px')\n          .style('height', margin + (maxBelowHeight || 0) + 'px');\n      } else {\n        const percent =\n          typeof mapping.category !== 'undefined'\n            ? Math.round(100 / (nestedData.length + 1)) * (i + 1)\n            : '50';\n        dom\n          .select(node[i])\n          .style('margin-top', '50px')\n          .style('margin-left', percent + '%')\n          .style('position', 'absolute');\n      }\n    });\n\n    // Execute render callback if provided\n    if (typeof callbackRender === 'function') {\n      callbackRender();\n    }\n  }\n\n  return api({\n    aggregateBy: setAggregateBy,\n    mapping: assignMapping,\n    optimize: setOptimizeLayout,\n    autoResize: setAutoResize,\n    orientation: setOrientation,\n    distribution: setDistribution,\n    scaleType: setScaleType,\n    parseTime: setParseTime,\n    labelFormat: setLabelFormat,\n    urlTarget: setUrlTarget,\n    useLabels: setUseLabels,\n    range: setRange,\n    render: render,\n    renderCallback: renderCallback,\n    onEventClick: setEventClickCallback,\n    onEventMouseLeave: setEventMouseLeaveCallback,\n    onEventMouseOver: setEventMouseOverCallback,\n  });\n}\n","import '../styles/styles.less';\nimport './example-styles.less';\n\nimport milestones from '../main';\n\n// used to increment the wrapping DIV's id.\nlet iteration = 0;\n\nexport const argTypes = {\n  optimize: {\n    control: { type: 'boolean' },\n  },\n  autoResize: {\n    control: { type: 'boolean' },\n  },\n  distribution: {\n    options: ['top-bottom', 'top', 'bottom'],\n    control: { type: 'radio' },\n  },\n  orientation: {\n    options: ['horizontal', 'vertical'],\n    control: { type: 'radio' },\n  },\n  aggregateBy: {\n    options: [\n      'second',\n      'minute',\n      'hour',\n      'day',\n      'week',\n      'month',\n      'quarter',\n      'year',\n    ],\n    control: { type: 'select' },\n  },\n  parseTime: {\n    control: { type: 'text' },\n  },\n  mapping: {\n    control: { type: 'object' },\n  },\n  data: {\n    control: { type: 'object' },\n  },\n  urlTarget: {\n    options: ['_blank', '_self', '_parent', '_top'],\n    control: { type: 'radio' },\n  },\n  scaleType: {\n    options: ['time', 'ordinal'],\n    control: { type: 'radio' },\n  },\n};\n\nexport const createMilestones = (\n  title,\n  description,\n  {\n    aggregateBy,\n    data,\n    distribution,\n    mapping,\n    optimize,\n    onEventClick,\n    onEventMouseOver,\n    onEventMouseLeave,\n    orientation,\n    parseTime,\n    autoResize,\n    urlTarget,\n    scaleType,\n  },\n  DIV_ID = 'timeline',\n  style = ''\n) => {\n  iteration++;\n\n  const divId = `${DIV_ID}-${iteration}`;\n\n  function render() {\n    const m = milestones(`#${divId}`);\n\n    mapping && m.mapping(mapping);\n    aggregateBy && m.aggregateBy(aggregateBy);\n    distribution && m.distribution(distribution);\n    optimize && m.optimize(optimize);\n    onEventClick && m.onEventClick(onEventClick);\n    onEventMouseOver && m.onEventMouseOver(onEventMouseOver);\n    onEventMouseLeave && m.onEventMouseLeave(onEventMouseLeave);\n    orientation && m.orientation(orientation);\n    parseTime && m.parseTime(parseTime);\n    autoResize && m.autoResize(autoResize);\n    urlTarget && m.urlTarget(urlTarget);\n    scaleType && m.scaleType(scaleType);\n\n    m.render(data);\n  }\n\n  // Wait until the wrapping DIV exists, only then render.\n  function checkElement() {\n    const wrapper = document.getElementById(divId);\n    if (!wrapper) {\n      window.setTimeout(checkElement, 100);\n    } else {\n      render();\n    }\n  }\n\n  checkElement();\n\n  const timeline = `<div id=\"${divId}\" class=\"timeline\" style=\"${style}\"></div>`;\n\n  if (!title && !description) {\n    return timeline;\n  }\n\n  return `\n    <div class=\"d3Milestones\">\n      ${title ? `<h2>${title}</h2>` : ''}\n      ${description ? `<p>${description}</p>` : ''}\n      ${timeline}\n    </div>\n  `;\n};\n"],"names":[],"sourceRoot":""}